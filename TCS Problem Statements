#Q1_weight of cloth -2000gm
#time to be taken- 25min 

#weight of cloth -4000gm
#time to taken- 45min

weight=int(input())
if weight<=0:
  print("Invalid")
elif weight>=1 and weight <=2000:
  print("Time instimated:25min")
elif  weight>=1 and weight <=3000:
  print("Time instimated:35min")
elif weight>=1 and weight <=4000:
  print("Time instimated:45min")
else:
  print("Overload")

#Q2_At a fun fair, a street vendor sells balloons in different colours. He sells N balloons in different colours (BI). The task is to find the balloon whose colour (odd) is present an odd number of times in the bunch of balloons.
Note: If more than one colour is odd in number, then the first colour in the array that is present odd number of times is displayed. The colours of the balloons can all be either upper-case or lower-case in the array. If all the inputs are
Example 1:
#Heading Heading 2
#•Z -> Value of N
#• [rgbbavy] B Elements B[0] to B[N-1], where each input element is sepirated by nen Iine.
#Output:
#[rabbayy]-> "r" colour balloon is present odd number of times in the bunch

Q_3)There is a JAR full of candies for sale at a mall counter. JAR has the capacity N, that is JAR can contain maximum N candies when JAR is full. At any point of time. 
JAR can have M number of Candies where M<=N. Candies are served to the customers. JAR is never remain empty as when last k candies are left. JAR if refilled with new candies in such a way that JAR get full. 
Write a code to implement above scenario. Display JAR at counter with available number of candies. Input should be the number of candies one customer can order at point of time. Update the JAR after each purchase and display JAR at Counter.

# Constants
N = 10  # Capacity of the jar

# Initialize jar
jar = [i for i in range(1, N+1)]

def display_jar():
    """Display the current state of the jar."""
    print(f"JAR at counter: [{', '.join(str(c) for c in jar)}]")

def serve_candies(num_candies):
    """Serve the given number of candies from the jar."""
    global jar
    if num_candies > len(jar):
        print("Not enough candies in the jar!")
        return
    jar = jar[:-num_candies]
    display_jar()

def refill_jar():
    """Refill the jar when there are only a few candies left."""
    global jar
    if len(jar) < N:
        # Refill the jar with candies from 1 to N
        jar = [i for i in range(1, N+1)]
        display_jar()

# Main loop
while True:
    # Get the number of candies a customer wants to order
    num_candies =4##int(input("Enter the number of candies you want to order: "))
    if num_candies > 0:
        serve_candies(num_candies)
    # Check if the jar needs to be refilled
        refill_jar()

Q_4) Problem Statement 1 - Given a string S(input consisting) of '' and '#'. The length of the string is variable. The task is to find the minimum number of '*' or '#' to make it a valid string. The string is considered valid if the number of '*' and '#' equals. The '*' and '#' can be at any position in the string.

Note: The output will be a positive or negative integer based on

several '*' and '#' in the input string.

• (*>#) positive integer

• (#>*) negative integer

(*).0

str=input()
star=0
hashh=0
#star=str.count('what we have to count')
#hashh=str.count('what we have to count')
for i in str:
  if i=="*":
    star+=1
  else:
    if i=='#':
      hashh+=1
print(star-has)

Q_5)Identify palindrome(String==reverse is called palindrome)

For a given positive number num. identify the palindrome formed by performing the following operation:-

        #add num and its reverse
        #check whether the sum is palindrome or not.if not, add the sum And its reverse and repeat the process until a palindrome is obtained.
#code_1
def reverse_number(n):
    """Helper function to reverse the digits of a number."""
    rev = 0
    while n > 0:
        rev = rev * 10 + (n % 10)
        n //= 10
    return rev

def is_palindrome(n):
    """Helper function to check if a number is palindrome."""
    return str(n) == str(n)[::-1]

def find_palindrome(num):
    """Function to find the palindrome as described."""
    current = num
    
    while True:
        # Step 1: Add current number with its reverse
        rev_current = reverse_number(current)
        sum_value = current + rev_current
        
        # Step 2: Check if the sum is a palindrome
        if is_palindrome(sum_value):
            return sum_value
        
        # Step 3: Update current number to the sum for next iteration
        current = sum_value

# Example usage:
num = 87
result = find_palindrome(num)
print(f"The palindrome formed is: {result}")

#Code_2
def ispalindrome(sum):
    return sum== int(str(sum)[::-1])
def rev(n):
    return int(str(n)[::-1])
    
n=int(input())
while(1):
    n=n+rev(n)
    if(ispalindrome(n)):
        print(n)
        break

Q_3)
    


    

